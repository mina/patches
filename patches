#!/bin/bash
#
# Workflow:
# git co -b my-branch --track net-next/main
# vim ...
# git a .
# git cm -m "my patch"
#
# # Creates patches under patches.my-branch/ to review what they look like:
# patches create -v 1
#
# # clang-format each patch in a git rebase --exec:
# patches clang_format
#
# # Run all non-build presubmits (faster):
# patches presubmit_quick
#
# # Run all the checks including builds (slow):
# patches presubmit
#
# # Run a set of nipa tests:
# patches patches nipa_test patch/deprecated_api,patch/verify_signedoff
#
# # Send the patches:
# patches send -v 1
#
# # Run all the presubmits and send the patches without confirming:
# patches send_no_confirm -v 1

set -e

TEST="${TEST:-0}"
RFC="${RFC:-0}"
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

head=$(git rev-parse --abbrev-ref --symbolic-full-name HEAD)
parent=$(git rev-parse --abbrev-ref --symbolic-full-name "@{u}")
tree="${parent:0:-5}"
git_send_to="netdev@vger.kernel.org"

echoerr() { cat <<< "$@" 1>&2; }

function create() {
	rm -rf "patches.$head"/*.patch

	local cover_letter=""
	local to=""
	local cc=""
	local files=""
	local range=""

	for commit in $(git rev-list "$head" --max-count=50); do
		if ! git show "$commit" --oneline | grep -q "not-for-review"; then
			break;
		fi
	done

	range="$parent..$commit"

	set +e
	git config branch."$head".description > .description.txt && \
		cover_letter="1"
	set -e

	count=$(($(git rev-list --count "$range")))

	if [[ "$count" -lt 1 ]]; then
		echo "Not enough commits in range: $count"
		exit 1
	fi

	if [[ "$count" -lt 1 ]] && [[ -n "$cover_letter" ]]; then
		cover_letter="--cover-letter --cover-from-description=auto --description-file=.description.txt"
	else
		cover_letter=""
	fi

	to=$(git diff "$range" | ./scripts/get_maintainer.pl \
		--no-git-fallback --norolestats -nom -nor --nomoderated \
		--nomultiline)

	cc=$(git diff "$range" | ./scripts/get_maintainer.pl \
		--git-min-percent 25 --norolestats -nol --nomoderated --nomultiline)

	if [[ $RFC == 0 ]]; then
		PREFIX="PATCH $tree"
	else
		PREFIX="PATCH RFC $tree"
	fi

	files=$(git format-patch \
		--base "$parent" \
		-o "patches.$head" \
		"$range" \
		$cover_letter \
		--to="$to" \
		--cc="$cc" \
		--subject-prefix="$PREFIX" \
		"$@")

	# Delete change-id
	for file in $files; do
		sed '/Change-Id:/d' "$file" -i
	done

	echo "$files"
}

send() {
	local files=""

	files=$(create "$@")
	CONFIRM=${CONFIRM:-}

	if [[ $TEST == 0 ]]; then
		DRY_RUN=
	else
		DRY_RUN="--dry-run"
	fi

	yes | git send-email $files --to="$git_send_to" --cc-cover --8bit-encoding=UTF-8 $CONFIRM $DRY_RUN || true

	git tag "$(date +%F-%s)-$head-${FUNCNAME[0]}"
}

# Runs a command on each patch
cmd_each_patch() {
	local cmd="$1"

	echo
	echo "rebasing exec $cmd"
	git rebase --exec \
		"git show | grep -q \"not-for-review\" || $cmd" \
		"$parent"
}

build_each_patch() {
	make mrproper

	touch .first_in_series

	cmd_each_patch "PATCHES_CONFIG=\"$SCRIPT_DIR/configs/test.config\" ~/patches/build_patch_with_checks.sh"

	echo "Test build patches succeeded"
}

clang_format() {
	cmd_each_patch "git diff -U0 --no-color HEAD~ | /usr/lib/clang-format/clang-format-diff.py -i -p1"
}

presubmit_quick() {
	git fetch "$tree"

	git rebase

	nipa_test patch/series_format,patch/tree_selection,patch/ynl,patch/fixes_present,patch/header_inline,patch/cc_maintainers,patch/verify_signedoff,patch/shellcheck,patch/deprecated_api,patch/pylint,patch/yamllint,patch/check_selftest,patch/verify_fixes,patch/checkpatch,patch/kdoc,patch/source_inline
}

presubmit() {
	presubmit_quick

: '
	patch/build_32bit
	patch/build_tools
	patch/build_clang
	patch/build_allmodconfig_warn
	patch/build_clang_rust
'

	nipa_test patch/build_allmodconfig_warn

	git tag "$(date +%F-%s)-$head-${FUNCNAME[0]}"
}

send_no_confirm() {
	presubmit

	CONFIRM="--confirm=never" send "$@"
}

nipa_test() {
	nipa_test="$1"

	create

	cat > nipa.config <<EOF
		[log]
		type = stdout
		path = none
		file = none

		[results]
		dir = ./patches.nipa/results

		[dirs]
		tests = $SCRIPT_DIR/nipa/tests

		[tests]
		include = $nipa_test
EOF

	rm -rf ./patches.nipa/
	mkdir -p ./patches.nipa/

	git branch -D nipa-scratch || true
	git checkout -b nipa-scratch

	"$SCRIPT_DIR"/nipa/ingest_mdir.py \
	  --mdir "$(pwd)"/patches."$head" \
	  --tree "$(pwd)" --tree-name "$tree" --tree-branch "$tree"/main

	git checkout "$head" -q

	for retcode in $(find patches.nipa -iname retcode); do
		ret="$(cat "$retcode")"
		if [[ $ret != "0" ]]; then
			echo Check failed: "$retcode"
			exit "$ret"
		fi
	done
}

command="$1"
shift

if [ "$command" == "create" ]; then
	create "$@"
elif [ "$command" == "send" ]; then
	send "$@"
elif [ "$command" == "send_no_confirm" ]; then
	send_no_confirm "$@"
elif [ "$command" == "build_each_patch" ]; then
	build_each_patch "$@"
elif [ "$command" == "presubmit" ]; then
	presubmit "$@"
elif [ "$command" == "presubmit_quick" ]; then
	presubmit_quick "$@"
elif [ "$command" == "clang_format" ]; then
	clang_format "$@"
elif [ "$command" == "nipa_test" ]; then
	nipa_test "$@"
fi
